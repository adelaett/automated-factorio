"""
This type stub file was generated by pyright.
"""

import numbers
import mip
from typing import List, Optional, Tuple, Union

"""
This type stub file was generated by pyright.
"""
class Solver:
    """The solver is an abstract class with the solver independent
    API to communicate with the solver engine"""
    def __init__(self: Solver, model: Model, name: str = ..., sense: str = ...) -> None:
        ...
    
    def __del__(self: Solver):
        ...
    
    def add_var(self: Solver, name: str = ..., obj: numbers.Real = ..., lb: numbers.Real = ..., ub: numbers.Real = ..., var_type: str = ..., column: Column = ...):
        ...
    
    def add_constr(self: Solver, lin_expr: mip.LinExpr, name: str = ...):
        ...
    
    def add_lazy_constr(self: Solver, lin_expr: mip.LinExpr):
        ...
    
    def add_sos(self: Solver, sos: List[Tuple[mip.Var, numbers.Real]], sos_type: int):
        ...
    
    def add_cut(self: Solver, lin_expr: mip.LinExpr):
        ...
    
    def get_objective_bound(self: Solver) -> numbers.Real:
        ...
    
    def get_objective(self: Solver) -> mip.LinExpr:
        ...
    
    def get_objective_const(self: Solver) -> numbers.Real:
        ...
    
    def relax(self: Solver):
        ...
    
    def generate_cuts(self, cut_types: Optional[List[mip.CutType]] = ..., depth: int = ..., npass: int = ..., max_cuts: int = ..., min_viol: numbers.Real = ...) -> mip.CutPool:
        ...
    
    def clique_merge(self, constrs: Optional[List[mip.Constr]] = ...):
        ...
    
    def optimize(self: Solver, relax: bool = ...) -> mip.OptimizationStatus:
        ...
    
    def get_objective_value(self: Solver) -> numbers.Real:
        ...
    
    def get_log(self: Solver) -> List[Tuple[numbers.Real, Tuple[numbers.Real, numbers.Real]]]:
        ...
    
    def get_objective_value_i(self: Solver, i: int) -> numbers.Real:
        ...
    
    def get_num_solutions(self: Solver) -> int:
        ...
    
    def get_objective_sense(self: Solver) -> str:
        ...
    
    def set_objective_sense(self: Solver, sense: str):
        ...
    
    def set_start(self: Solver, start: List[Tuple[mip.Var, numbers.Real]]):
        ...
    
    def set_objective(self: Solver, lin_expr: mip.LinExpr, sense: str = ...):
        ...
    
    def set_objective_const(self: Solver, const: numbers.Real):
        ...
    
    def set_processing_limits(self: Solver, max_time: numbers.Real = ..., max_nodes: int = ..., max_sol: int = ..., max_seconds_same_incumbent: float = ..., max_nodes_same_incumbent: int = ...):
        ...
    
    def get_max_seconds(self: Solver) -> numbers.Real:
        ...
    
    def set_max_seconds(self: Solver, max_seconds: numbers.Real):
        ...
    
    def get_max_solutions(self: Solver) -> int:
        ...
    
    def set_max_solutions(self: Solver, max_solutions: int):
        ...
    
    def get_pump_passes(self: Solver) -> int:
        ...
    
    def set_pump_passes(self: Solver, passes: int):
        ...
    
    def get_max_nodes(self: Solver) -> int:
        ...
    
    def set_max_nodes(self: Solver, max_nodes: int):
        ...
    
    def set_num_threads(self: Solver, threads: int):
        ...
    
    def write(self: Solver, file_path: str):
        ...
    
    def read(self: Solver, file_path: str):
        ...
    
    def num_cols(self: Solver) -> int:
        ...
    
    def num_rows(self: Solver) -> int:
        ...
    
    def num_nz(self: Solver) -> int:
        ...
    
    def num_int(self: Solver) -> int:
        ...
    
    def get_emphasis(self: Solver) -> mip.SearchEmphasis:
        ...
    
    def set_emphasis(self: Solver, emph: mip.SearchEmphasis):
        ...
    
    def get_cutoff(self: Solver) -> numbers.Real:
        ...
    
    def set_cutoff(self: Solver, cutoff: numbers.Real):
        ...
    
    def get_mip_gap_abs(self: Solver) -> numbers.Real:
        ...
    
    def set_mip_gap_abs(self: Solver, mip_gap_abs: numbers.Real):
        ...
    
    def get_mip_gap(self: Solver) -> numbers.Real:
        ...
    
    def set_mip_gap(self: Solver, mip_gap: numbers.Real):
        ...
    
    def get_verbose(self: Solver) -> int:
        ...
    
    def set_verbose(self: Solver, verbose: int):
        ...
    
    def constr_get_expr(self: Solver, constr: mip.Constr) -> mip.LinExpr:
        ...
    
    def constr_set_expr(self: Solver, constr: mip.Constr, value: mip.LinExpr) -> mip.LinExpr:
        ...
    
    def constr_get_rhs(self: Solver, idx: int) -> numbers.Real:
        ...
    
    def constr_set_rhs(self: Solver, idx: int, rhs: numbers.Real):
        ...
    
    def constr_get_name(self: Solver, idx: int) -> str:
        ...
    
    def constr_get_pi(self: Solver, constr: mip.Constr) -> numbers.Real:
        ...
    
    def constr_get_slack(self: Solver, constr: mip.Constr) -> numbers.Real:
        ...
    
    def remove_constrs(self: Solver, constrsList: List[int]):
        ...
    
    def constr_get_index(self: Solver, name: str) -> int:
        ...
    
    def var_get_branch_priority(self: Solver, var: mip.Var) -> numbers.Real:
        ...
    
    def var_set_branch_priority(self: Solver, var: mip.Var, value: numbers.Real):
        ...
    
    def var_get_lb(self: Solver, var: mip.Var) -> numbers.Real:
        ...
    
    def var_set_lb(self: Solver, var: mip.Var, value: numbers.Real):
        ...
    
    def var_get_ub(self: Solver, var: mip.Var) -> numbers.Real:
        ...
    
    def var_set_ub(self: Solver, var: mip.Var, value: numbers.Real):
        ...
    
    def var_get_obj(self: Solver, var: mip.Var) -> numbers.Real:
        ...
    
    def var_set_obj(self: Solver, var: mip.Var, value: numbers.Real):
        ...
    
    def var_get_var_type(self: Solver, var: mip.Var) -> str:
        ...
    
    def var_set_var_type(self: Solver, var: mip.Var, value: str):
        ...
    
    def var_get_column(self: Solver, var: mip.Var) -> Column:
        ...
    
    def var_set_column(self: Solver, var: mip.Var, value: Column):
        ...
    
    def var_get_rc(self: Solver, var: mip.Var) -> numbers.Real:
        ...
    
    def var_get_x(self: Solver, var: mip.Var) -> numbers.Real:
        """Assumes that the solution is available (should be checked
        before calling it"""
        ...
    
    def var_get_xi(self: Solver, var: mip.Var, i: int) -> numbers.Real:
        ...
    
    def var_get_name(self: Solver, idx: int) -> str:
        ...
    
    def remove_vars(self: Solver, varsList: List[int]):
        ...
    
    def var_get_index(self: Solver, name: str) -> int:
        ...
    
    def get_problem_name(self: Solver) -> str:
        ...
    
    def set_problem_name(self: Solver, name: str):
        ...
    
    def get_status(self: Solver) -> mip.OptimizationStatus:
        ...
    
    def cgraph_density(self: Solver) -> float:
        """Density of the conflict graph"""
        ...
    
    def conflicting(self: Solver, e1: Union[mip.LinExpr, mip.Var], e2: Union[mip.LinExpr, mip.Var]) -> bool:
        """Checks if two assignment to binary variables are in conflict,
        returns none if no conflict graph is available"""
        ...
    
    def conflicting_nodes(self: Solver, v1: Union[mip.Var, mip.LinExpr]) -> Tuple[List[mip.Var], List[mip.Var]]:
        """Returns all assignment conflicting with the assignment in v1 in the
        conflict graph.
        """
        ...
    
    def feature_values(self: Solver) -> List[float]:
        ...
    
    def feature_names(self: Solver) -> List[str]:
        ...
    


